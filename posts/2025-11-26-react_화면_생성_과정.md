---
title: "React 화면 생성 과정과 렌더링 전략 (CSR vs SSG)"
date: "2025-11-26"
category: "Language & Framework"
tags: [React, Next.js, CSR, SSG, Vite]
description: "React의 동작 원리(Lifecycle)를 이해하고 Next.js가 필요한 이유를 정리함."
---

# 🛠️ React 화면 생성 과정 및 렌더링 전략

## 🎯 Goal (목표)

React가 브라우저에서 화면을 구성하는 구체적인 라이프사이클을 이해함으로써, Next.js가 제공하는 SSG, SSR이 CSR(React)과 기술적으로 어떻게 다르며 언제 사용해야 하는지 명확히 구분한다.

## 💻 동작 원리

### Step 1. Setup (Build & Bundle)

- **빌드(Build):** React 프로젝트(Vite 사용)를 빌드하면 결과물로 `index.html`(껍데기)과 `Javascript Bundle`(알맹이)이 생성된다.
- **번들(Bundle):** 별도의 Code Splitting(React.lazy 등) 설정이 없다면, 이 번들 파일 하나에 모든 페이지의 컴포넌트 정보가 포함된다.
- **Vite의 역할:**
  - **개발 시:** Native ESM 방식을 사용하여 번들링 없이 즉시 브라우저에 코드를 제공(HMR 속도 최적화).
  - **배포 시:** `esbuild`를 사용해 고속으로 코드를 압축하고 번들링하여 최적화된 정적 파일을 생성.

### Step 2. CSR (Client Side Rendering) Flow

브라우저가 URL을 요청했을 때 일어나는 실제 과정은 다음과 같다:

1.  **요청:** 브라우저가 서버로부터 텅 빈 `index.html`을 다운로드한다.
2.  **로딩:** HTML 내의 `<script>` 태그를 통해 거대한 JS Bundle을 요청 및 다운로드한다.
3.  **파싱 및 실행 (Parsing & Execution):**
    - 브라우저 JS 엔진이 코드를 해석(Parsing)하여 메모리에 적재한다.
    - React 코드가 실행되면서 메모리 상에 **Virtual DOM(가상 돔)**을 생성한다.
4.  **마운트 (Mounting):** Virtual DOM의 내용을 실제 브라우저 화면(Real DOM)에 강제로 주입(Commit)한다. (이때 사용자에게 UI가 보임)
5.  **Side Effect:** 화면이 그려진 직후 `useEffect` 등의 훅이 비동기적으로 실행된다.

### Step 3. Rendering Strategy Comparison

- **React (CSR):**
  - 서버는 정적 파일만 제공하면 되므로 **서버 부담(연산 비용)이 전무**하다.
  - 모든 렌더링 부하를 브라우저(클라이언트)가 부담하며, 초기 로딩 시 JS 다운로드 및 파싱으로 인해 속도가 느릴 수 있다.
- **Next.js (SSG/SSR):**
  - React에서 SSG를 하려면 별도 라이브러리와 복잡한 설정이 필요하다.
  - Next.js는 페이지별로 CSR, SSR, SSG를 혼용할 수 있는 하이브리드 전략을 기본 제공하므로 생산성이 월등히 높다.

## 💡 회고

### 현업 활용 가이드

- **React (CSR) 추천:** SEO가 필요 없는 **관리자 페이지(Admin)**, **SaaS 서비스 대시보드**, 폐쇄형 커뮤니티 등. AWS S3 + CloudFront 조합으로 서버리스 배포하는 것이 표준이다.
- **Next.js 추천:** SEO가 중요한 **이커머스**, **랜딩 페이지**, **블로그** 등. Vercel이나 Docker 컨테이너로 배포한다.

### 주의할 점 (Gotchas)

- **White Screen:** CSR은 JS가 다 받아지기 전까지 사용자가 흰 화면만 보게 된다. 이를 방지하기 위해 스켈레톤 UI(Skeleton UI) 등을 적용해야 한다.
- **useEffect 시점:** `useEffect`는 화면이 **모두 그려진 뒤**에 실행된다. 따라서 초기 렌더링에 필요한 데이터는 `useEffect`가 아니라 가능한 상위에서 미리 처리하거나, 로딩 처리를 꼼꼼히 해야 한다.
