---
title: "RSC_중심_아키텍처_및_최적화"
date: "2025-11-27"
category: "Language & Framework"
tags: [Next.js, RSC, AppRouter, Optimization]
description: "Next.js App Router의 RSC 아키텍처와 자동 코드 스플리팅, 프리패칭을 통한 성능 최적화 원리 정리."
---

# 🛠️ `RSC_중심_아키텍처`

## 🎯 Goal (목표)

기존의 SSG, SSR, CSR 구분법을 넘어, 최신 Next.js(App Router)의 핵심인 **RSC(React Server Components)**가 어떻게 "JS 없는 SSG"를 구현하는지 이해한다. 또한 Next.js 고유의 **번들링 전략(Splitting)**과 **프리패칭(Prefetching)** 원리를 학습하여 React(Vite) 대비 성능 우위를 점하는 이유를 파악한다.

## 💻 Implementation (구현 과정)

### Step 1. Setup

```bash
# 최신 Next.js 프로젝트 생성 (App Router 자동 적용)
npx create-next-app@latest portfolio
```

### Step 2. Code Snippet (RSC vs CC)

#### 1. Server Component (기본값)

```tsx
// app/page.tsx
// JS 번들이 브라우저로 전송되지 않음 (0KB). 서버에서 HTML만 생성.
export default async function PortfolioMain() {
  const projects = await getProjectsFromDB(); // DB 직접 접근 가능
  return (
    <main>
      <h1>나의 포트폴리오</h1>
      {/* 정적 컨텐츠는 HTML로 박제되어 전송됨 */}
      {projects.map((p) => (
        <div key={p.id}>{p.name}</div>
      ))}
    </main>
  );
}
```

#### 2. Client Component (필요시에만)

```tsx
"use client"; // 👈 이 선언이 있는 파일과 그 자식들만 JS 번들로 다운로드됨

import { useState } from "react";

export default function LikeButton() {
  const [likes, setLikes] = useState(0);
  return <button onClick={() => setLikes(likes + 1)}>👍 {likes}</button>;
}
```

### Step 3. Performance Mechanism (Next.js가 빠른 이유)

#### 1. Automatic Code Splitting (자동 코드 분할)

- **React (Vite):** **"All-in-One"**. 최초 접속 시 전체 페이지(`/about`, `/mypage` 등)의 코드가 담긴 거대한 `bundle.js`를 한 번에 다운로드함. (초기 로딩 느림)
- **Next.js:** **"Just-in-Time"**. 사용자가 접속한 해당 페이지(Route)에 필요한 JS만 쪼개서 보냄. 심지어 RSC라면 JS를 아예 안 보냄.

#### 2. Link Prefetching (미리 가져오기)

- **동작 원리:** 뷰포트(화면)에 `<Link href="/about">` 컴포넌트가 나타나는 순간, Next.js는 백그라운드에서 조용히 `/about` 페이지의 리소스를 미리 다운로드함.
- **결과:** 사용자가 버튼을 클릭했을 때는 이미 데이터가 준비되어 있어 **즉시 이동(Instant Navigation)**함.

#### 3. 번들링 비교 요약표

| 구분                | React (Vite)          | Next.js (App Router)                  |
| :------------------ | :-------------------- | :------------------------------------ |
| **JS 번들 크기**    | 큼 (모든 페이지 포함) | 작음 (현재 페이지만 + RSC는 0KB)      |
| **초기 로딩 (LCP)** | 느림                  | **매우 빠름** (필요한 것만 받음)      |
| **페이지 이동**     | 빠름 (이미 다 있음)   | **매우 빠름** (Prefetching 기술 적용) |

## 💡 Best Practices

- **현업에서는 주로 이렇게 사용함:**

  - **Default는 무조건 RSC:** 페이지의 뼈대, 레이아웃, 데이터 페칭은 전부 서버 컴포넌트로 작성하여 브라우저가 다운로드할 JS 양을 극단적으로 줄임.
  - **Leaf Node만 CC:** 버튼, 검색창 같이 상호작용이 필요한 '말단 컴포넌트'만 `"use client"`로 분리.
  - **Link 컴포넌트 적극 활용:** `a` 태그 대신 Next.js의 `<Link>`를 사용하여 프리패칭 효과를 누림.

- **주의할 점 (Gotchas):**
  - **Server to Client Props:** 서버 컴포넌트에서 클라이언트 컴포넌트로 데이터를 넘길 때, 함수(Function)는 넘길 수 없음. (직렬화 가능한 JSON 데이터만 가능)
  - **무분별한 "use client":** 최상위 `layout.tsx`에 `"use client"`를 붙이면 하위 모든 페이지가 클라이언트 렌더링으로 바뀌어 Next.js의 장점(RSC)이 사라짐.
